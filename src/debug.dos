 // 清理缓存
        clearAllCache();
        
        // 区间收益率计算函数 -> FutureReturn1..30
        def ReturnCal(data, idCol, openCol, closeCol, periodSize){
            df = data;
            df[`open] = df[openCol];
            df[`close] = df[closeCol];
            df[`id] = df[idCol]
            update df set FutureReturn = (move(close,-periodSize)-close)\close context by id;
            // res = sql(select=sqlColAlias(<(move(close,-periodSize)-close)\close>,`FutureReturn),
                // from=df,groupBy=sqlCol(idCol),groupFlag=0).eval()
            return exec FutureReturn from df
        }
        // 区间超额收益率计算函数 -> // FutureReturn1..30
        def ReturnOverCal(data, idCol, openCol, closeCol, benchmarkOpenCol, benchmarkCloseCol, periodSize){
            df = data;
            df[`open] = df[openCol];
            df[`close] = df[closeCol];
            df[`benchmarkOpen] = df[benchmarkOpenCol]
            df[`benchmarkClose] = df[benchmarkCloseCol]
            update df set FutureReturn = (move(close,-periodSize)-close)/close - (move(benchmarkClose,-periodSize)-benchmarkClose)/benchmarkClose context by id
            // res = sql(select=sqlColAlias(<(move(close,-periodSize)-close)/close - (move(benchmarkClose,-periodSize)-benchmarkClose)/benchmarkClose>,`FutureReturn+string(periodSize)),
                // from=df,groupBy=sqlCol(idCol),groupFlag=0).eval()
            return exec FutureReturn from res
        }
        
        // Index Component Constraint
        idx_code = "000852.SH"//"399300.SZ";
        index_df = select con_code as symbol,trade_date as date from loadTable("dfs://DayKDB","o_tushare_index_weight") where index_code == idx_code and trade_date between date(2017.01.01) and temporalAdd(date(2025.04.30), 1 ,"XSHG"); // 成分股信息
        symbol_list = exec distinct(symbol) as component from index_df;
        
        // 补全index_df
        total_date_list = getMarketCalendar("XSHG", date(2017.01.01), temporalAdd(date(2025.04.30), 1 ,"XSHG"))
        current_date_list = sort(exec distinct(date) from index_df);
        last_date = current_date_list[0]
        for (i in 1..size(total_date_list)-1){
            ts = total_date_list[i]
            if (!(ts in current_date_list)){
                // 离他最近比它小的date
                index_df.append!(select symbol, ts as `date from index_df where date == last_date)      
            }else{
                last_date = ts
            }
        }
        sortBy!(index_df,`date`symbol,[1,1]);
        
        // Symbol df processing
        symbol_df=select symbol,date,minute,open,close,marketvalue,state,industry from loadTable('dfs://asset_cn/ReturnModel','DayFreqSymbol') where date between date(2017.01.01) and temporalAdd(date(2025.04.30), 1 ,"XSHG") and symbol in symbol_list;        
        // bar_return & Period_return
        update symbol_df set bar_return = nullFill((next(close)-close)/close,0.0) context by symbol;
        update symbol_df set bar_return = clip(bar_return, -0.1, 0.1);
        idCol = `symbol;
        openCol = `open;
        closeCol = `close;
        returnIntervals = [1, 5, 10, 20, 30]
        returnFunc = ReturnCal{symbol_df, idCol, openCol, closeCol}   // TODO: 价格参数确定计算的区间收益率函数类型
        returnRes = each(returnFunc, returnIntervals)
        for (i in 0..(size(returnIntervals)-1)){
            interval = returnIntervals[i]
            symbol_df[`FutureReturn+string(interval)] = returnRes[i]
        }
        print("未来区间收益率计算完毕") // for ICIR & 回归法
        symbol_df = lj(index_df,symbol_df,`symbol`date);
        undef(`index_df);
        
         // 新增一个period的frame[日频决策,与因子部分保持一致]
        sortBy!(symbol_df,[`symbol,`date,`minute],[1,1,1]); // 正序排序
        for (i in seq(1,int(1))){  // 这里后续可以根据调仓周期去灵活变换
            pt=select temporalAdd(lastNot(date),1,"XSHG") as date,1500 as minute,NULL as open,NULL as close,NULL as marketvalue,nullFill(last(state),1) as state,NULL as industry,0.0 as bar_return,0.0 as FutureReturn1,0.0 as FutureReturn5,0.0 as FutureReturn10,0.0 as FutureReturn20,0.0 as FutureReturn30 from symbol_df group by symbol; // 选取最后一个日期加一的形式作为决策的形式
            symbol_df.append!(pt);
        };
        undef(`pt);
        update symbol_df set industry = industry.ffill() context by symbol;  // 假设industry不变
        print("Symbol添加完毕")
        
        // Period of processing
        symbol_df[`monthidx]=0;
        symbol_df[`weekidx]=0;
        df=select first(monthidx) as monthidx,first(weekidx) as weekidx, 1 as dateidx from symbol_df group by date;
        sortBy!(df,`date,[1]);
        update df set monthdelta=date-monthBegin(date);
        update df set weekdelta=date-weekBegin(date);
        update df set monthidx=1 where date=min(date) or monthdelta<=prev(monthdelta);
        update df set weekidx=1 where date=min(date) or weekdelta<=prev(weekdelta);
        update df set period_month=cumsum(monthidx); // 月频period
        update df set period_week=cumsum(weekidx); // 周频period
        update df set period_date=cumsum(dateidx); // 日频period
        
        // 月频调仓/K月频
        // month_Dict=dict(df[`date],df[`period_month]);
        // update symbol_df set period=month_Dict[date];
        
        // 周频调仓/K周频
        // week_Dict=dict(df[`date],df[`period_week]);
        // update symbol_df set period=week_Dict[date];
        // update symbol_df set period=int(double(period)/2)

        // 日频调仓/K日频 (暂不支持分钟频调仓)
        day_Dict=dict(df[`date],df[`period_date]);
        update symbol_df set period=day_Dict[date];
        
        dropColumns!(symbol_df,`monthidx`weekidx);
        undef(`df);
        
        // Benchmark df processing
        benchmark_df=select date,minute,open as b000852_open,close as b000852_close from loadTable("dfs://asset_cn/ReturnModel","DayFreqBenchmark"); // 这里只设了一个benchmark
        symbol_df=lj(symbol_df,benchmark_df,`date`minute);
        undef(`benchmark_df); 
        print("Benchmark 添加完毕")
        
        // Factor df processing
        factor_list=['shio', 'shioStrong', 'shioWeak', 'shio_avg20', 'shioStrong_avg20', 'shioWeak_avg20', 'shio_std20', 'shioStrong_std20', 'shioWeak_std20']; 
        factor_pt=select symbol,date,minute,shio,shioStrong,shioWeak,shio_avg20,shioStrong_avg20,shioWeak_avg20,shio_std20,shioStrong_std20,shioWeak_std20 from loadTable("dfs://asset_cn/factor","DayFreq20250806") where date >= 2017.01.01 and symbol in symbol_list;
        symbol_df=lj(symbol_df,factor_pt,`symbol`date`minute);
        undef(`factor_pt)
        print("Factor 添加完毕")

        // 添加至数据库
        def InsertData(DBName, TBName, data, batchsize){
            // 预防Out of Memory，分批插入数据，batchsize为每次数据的记录数
            start_idx = 0
            end_idx = batchsize
            krow = rows(data)
            do{ 
                slice_data = data[start_idx:min(end_idx,krow),]
                if (rows(slice_data)>0){
                loadTable(DBName, TBName).append!(slice_data);
                }
                start_idx = start_idx + batchsize
                end_idx = end_idx + batchsize
            }while(start_idx < krow)
        }
        InsertData(DBName="dfs://asset_cn/Combine/DayFreq20250806",TBName="combination",data=nullFill(symbol_df,0),batchsize=1000000); 